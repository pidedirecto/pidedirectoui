import { ArgTypes, Canvas, Meta, Story } from '@storybook/blocks';

import * as ButtonStories from '../../stories/Button.stories';

<Meta of={ButtonStories} />

# Button

Renders a Button

<Canvas of={ButtonStories.Primary} />

## onClick event

To listen to the onClick it is as simple as passing an `onClick` prop with a function as a value, the function can be synchronous or asynchronous.

```tsx
const handleClick = () => console.log('Hi!!');

<Button onClick={handleClick}>button</Button>;
```

## Button variants

The primary variant is the main one, you don't have to pass anything to the button to render this version

### Secondary

<Canvas of={ButtonStories.Secondary} />

You can change the secondary button through the theme

### Outline

<Canvas of={ButtonStories.Outline} />

You can change the outline button through the theme

### Text

<Canvas of={ButtonStories.Text} />

### Icon

<Canvas of={ButtonStories.Icon} />

## Badge

You can add a badge to `Button` component through `badge` prop

<Canvas of={ButtonStories.Badge} />

badge content can be any valid `React.ReactNode`, but we recommend using `Chip` component. If you want to change the badge position, you can do it simple with position absolute css attributes using either classes or styles directly.

<Canvas of={ButtonStories.BadgePositioned} />

## asDiv

Sometimes we want to show clickable elements inside other clickable elements, for this case we must use the `asDiv` prop,
this will render a div element semantically equal to a button element. This obviously comes with some drawbacks, due to it
is not the native button element, specially when the button is inside other contexts, for example this button equivalence
won't trigger a form submit event. We should avoid using this equivalence but when the design requires it we should use this
option instead of nesting buttons.

## API

Here there are described some of the custom props, but the `Button` component can receive almost any of the HTML input props.

<ArgTypes of={ButtonStories} />
